<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<title>弹性布局</title>
</head>
<style>
     *{
     	padding: 0;
     	margin: 0;
     }
	.wrap{
		width: 800px;
		height: 1000px;
		border: 1px solid red;
		/*display:flex;定义弹性盒子*/
		display: flex;
		/*flex-wrap:wrap;规定子集是否换行，默认是nowrap*/
		flex-wrap: wrap;
		/*flex-direction:规定子集在父级里的排列方向：
		row子级沿着弹性盒子的x轴方向，从左至右排列
		row-reverse：子级沿着弹性盒子的x轴方向，从右至左排列
		column：子级沿着弹性盒子的y轴方向，从上至下排列
		column-reverse：子级沿着弹性盒子的y轴方向，从下至上排列*/
		flex-direction: row;
		/*flex-flow;是flex-direction和flexwrap的简写形式*/
		flex-flow: wrap row;
		/*设置子级在水平方向的分布
		flex-start：子级局左
		flex-end：子级局右
		center：水平局中
		space-betwwen：平均分布
		space-around：子级两侧有间隙，类似左右margin的效果
		space-betwwen：平均分布
		*/
	    /*justify-content: space-around;水平分布*/
		justify-content: space-around;
		/*align-content:设置子级垂直分布，适合多行分布
		 子级在父级垂直方向上的分布：
         flex-star：子级顶部与父级顶部对齐
         flex-end：子级底部与父级底部对齐
         center：子级垂直方向居中
         stretch：拉伸（默认值）
		*/
		/*align-items: stretch;适合单行分布*/
	}
	.wrap p{
		width: 210px;
		height: 300px;
	}
	.wrap p:nth-child(3n+1){
		background: blue;
	}
	.wrap p:nth-child(3n+2){
		background: yellow;
	}
	.wrap p:nth-child(3n+3){
		background: green;
	}
	.wrap p:nth-child(1){
		order: 3;
	}
	.wrap p:nth-child(2){
		order: 1;
	}
	.wrap p:nth-child(3){
		order: 2;
	}
	.wrap p:nth-child(4){
		order: 6;
	}
	.wrap p:nth-child(5){
		order: 4;
	}
	.wrap p:nth-child(6){
		order: 5;
	}
</style>
<body>
	<div class="wrap">
		<p> p1可以打开这个 demo（下文中所有的 demo 都在这个页面） 然后用开发工具查看一下。注意不要用截图工具量，可能量不准，因为高分屏和放大等诸多因素都会影响测量结果。
		</p>
		<p> p2当所有元素的 flex-grow 之和小于 1 的时候（注意是 1，也就是说每个元素的 flex-grow 都是一个小数如 0.2 这样的），上面式子中的 sum 将会使用 1 来参与计算，而不论它们的和是多少。也就是说，当所有的元素的 flex-grow 之和小于 1 的时候，剩余空间不会全部分配给各个元素。
		</p>
		<p> p3实际上用来分配的空间是 sum(flex-grow) / 1 * 剩余空间，这些用来分配的空间依然是按 flex-grow 的比例来分配。
		</p>
		<p>p4 可以打开这个 demo（下文中所有的 demo 都在这个页面） 然后用开发工具查看一下。注意不要用截图工具量，可能量不准，因为高分屏和放大等诸多因素都会影响测量结果。
		</p>
		<p> p5当所有元素的 flex-grow 之和小于 1 的时候（注意是 1，也就是说每个元素的 flex-grow 都是一个小数如 0.2 这样的），上面式子中的 sum 将会使用 1 来参与计算，而不论它们的和是多少。也就是说，当所有的元素的 flex-grow 之和小于 1 的时候，剩余空间不会全部分配给各个元素。
		</p>
		<p> p6实际上用来分配的空间是 sum(flex-grow) / 1 * 剩余空间，这些用来分配的空间依然是按 flex-grow 的比例来分配。
		</p>
	</div>
</body>
</html>